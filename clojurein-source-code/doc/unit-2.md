# Recursion

## Simple Recursion

First we look at a function which uses simple recursion to sum the elements of a given list.

```
(defn sum-list-sr [nums] ;; sr stands for simple-recursion
  (if (empty? nums)
    0
    (+ (first nums)
       (sum-list-sr (rest nums)))))
```

This function works fine for small lists.

```
(sum-list-sr '(1 -2 3 -4 5))
==> 3
```

The function also works for vectors.

```
(sum-list-sr [1 -2 3 -4 5])
==> 3
```

In fact the function works for an given object which obeys the sequence API, i.e.,
an object which implements `first` and `rest`.  

```
(first '(1 -2 3 -4 5))
==> 1
(rest '(1 -2 3 -4 5))
==> '(-2 3 -4 5)

(first '[1 -2 3 -4 5])
==> 1
(rest [1 -2 3 -4 5])
==> '(-2 3 -4 5)
```

It may be a little bit surprising that `rest` called with a vector as argument
returns a list; however, this fact makes the function `sum-list-sr` efficient.
Computing `rest` of a list is a constant time, constant memory operation because
linked lists can share tails.
However, computing `[-2 3 -4 5]` from `[1 -2 3 -4 5]` from would be a linear time, linear memory
operation as vectors cannot share tails.  `(rest [1 -2 3 -4 5])` is a linear time, linear memory
operation, but since it returns a list, subsequent calls to `rest` will be constant time, constant memory operations.

A limitation of the function `sum-list-sr` is that each recursive call
requires memory allocation to push local state onto a stack, and each
return from a recursive call requires work to restore local state.

```
(sum-list-sr (range 100))
==> 4950
(sum-list-sr (range 1000))
==> 499500
(sum-list-sr (range 10000))
Execution error (StackOverflowError) at user/sum-list-sr (form-init7718652093210840400.clj:46).
```

## Tail recursion  `loop` and `recur`

The problem of stack overflow can be solved using tail recursion, because Clojure as well
as many functional programming languages implements so-called tail-call-optimization.

We'll look at two possible implementations.

```
(defn sum-list-tr [seq-of-nums]
  (loop [acc 0
         nums seq-of-nums]
   (if (empty? nums)
     acc
     (recur (+ acc (first nums))
            (rest nums)))))
```

The first implementation uses `loop`/`recur`.  `loop` allows us to
specify a set of recursion variables `acc` and `nums`, with initial values `0` and `seq-of-nums`.
If the sequence is empty, then the accumulated value is returned, otherwise
the first element is of the sequence is added to the accumulator and recursion occurs
via the `recure` form.

Next we have an alternative, using the so-called mult-arity function definition.
This defines one function `sum-list-tr` which may be called either with a single
argument or with two arguments.  The first clause is activated for single argument `[nums]`
and the second clause is activated if two arguments `[nums acc]` are given.
In this case we use `recur` without `loop`.  Looking up the scope from `recur`, if `loop` is
found, it is used as the recursion point, otherwise the inner most function definition is used,
whether this is a named function, an anonymous function, a function defined using `letfn`
or any other.

In the single argument case, we simply call the two argument clause with `0` as the
initial value of the accumulator, `acc`.


```
(defn sum-list-tr 
  ([nums]
   (sum-list-tr nums 0))
  ([nums acc]
   (if (empty? nums)
     acc
     (recur (rest nums)
            (+ acc (first nums))))))
```

## Folding `reduce`

Finally, a very terse version of this function can be implemented using `reduce` as shown here.
To call `reduce` we need three values: a binary function, an inital value, and a sequence.
If the initial value is omitted, it is implicitly generated by calling the given funciton, `+`
in this case, with no arguments.  Evaluating `(+)` returns 0.

```
(defn sum-reduce
  [nums]
  (reduce + 0 nums))
```
